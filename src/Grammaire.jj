/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Grammaire.jj */
/*@egen*//**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */

PARSER_BEGIN(Main)

public class Main/*@bgen(jjtree)*/implements MainTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTMainState jjtree = new JJTMainState();

/*@egen*/
   static Main parser = null;
	
	public static void main(String[] args) {
		JFrame guiFrame = new JFrame();
        
        //make sure the program exits when the frame closes
        guiFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        guiFrame.setTitle("Graphical User Interface");
        guiFrame.setSize(300,600);
      
        //This will center the JFrame in the middle of the screen
        guiFrame.setLocationRelativeTo(null);
        
        //The first JPanel contains a label and text field for entering the expression
        final JPanel inputPanel = new JPanel();
        JLabel inputLbl = new JLabel("Enter your Expression: ");
        final JTextField inputText = new JTextField("");
        inputText.setColumns(20);
        
        inputPanel.add(inputLbl);
        inputPanel.add(inputText);
        
		// The bottom Panel contains a text box for showing results of a parse
        final JTextArea outputText = new JTextArea();
        outputText.setColumns(20);
        outputText.setRows(10);

                     
        
        JPanel mainPanel = new JPanel();
        mainPanel.add(inputPanel);
        mainPanel.add(outputText);
        
        //Christophe
        JMenuBar bar = new JMenuBar();
        JMenu menu = new JMenu("File");
        JMenuItem file = new JMenuItem("S\u00e9lectionner un fichier");
        
        menu.add(file);
        bar.add(menu);
        guiFrame.setJMenuBar(bar);
        
        final JFileChooser fileChooser = new javax.swing.JFileChooser();
        fileChooser.setFileSelectionMode(javax.swing.JFileChooser.FILES_AND_DIRECTORIES);
        
        file.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
            	   
            	int returnVal = fileChooser.showOpenDialog(guiFrame);

            	if (returnVal == JFileChooser.APPROVE_OPTION) {
            		File selectedFile = fileChooser.getSelectedFile();
            		
            		try {
						InputStream f = new FileInputStream(selectedFile);
						
						InputStreamReader fr = new InputStreamReader(f);
						
						BufferedReader br = new BufferedReader(fr);
						String chaine="";
						String ligne;
						while ((ligne=br.readLine())!=null){
							String sentence = ligne;
							Main parser = new Main(new java.io.StringReader(sentence));
                           	parser.ReInit(new java.io.StringReader(sentence));
							inputText.setText(sentence);
			                // Put parens around sentence so that parser knows scope
			                sentence = "(" + sentence + ")";
			                InputStream is = new ByteArrayInputStream(sentence.getBytes());
			                if(parser == null) parser = new Main(is);
			                else Main.ReInit(is);
			                try
			                {
			                  	outputText.setText("expression parsed ok.");
                				SimpleNode root = parser.start();
                				root.dump("");
			                }
			                catch (Exception e)
			                {
			                  outputText.setText("error in expression.\n"+
			                		  				e.getMessage());
			                }
			                catch (Error e)
			                {
			                 outputText.setText("error in expression.\n"+
			    		  						   e.getMessage());
			                }
			                finally
			                {
			                  
			                }
							chaine+=ligne+"\n";
						}
						
					} catch (IOException e) {
						e.printStackTrace();
					}
            	}
            }       
        });
        
     
        // Textfield Action Listener callback - executed when user hits "return"
        inputText.addActionListener(new ActionListener() {
        	public void actionPerformed(ActionEvent evt) {
        	  	String sentence = inputText.getText();
        	  	Main parser = new Main(new java.io.StringReader(sentence));
                
                // Put parens around sentence so that parser knows scope
                sentence = "(" + sentence + ")";
                InputStream is = new ByteArrayInputStream(sentence.getBytes());
                if(parser == null) parser = new Main(is);
                else Main.ReInit(is);
                try
                {
                 
                    outputText.setText("expression parsed ok.");
                	SimpleNode root = parser.start();
                	root.dump("");
                
                  
                  
                }
                catch (Exception e)
                {
                  outputText.setText("error in expression.\n"+
                		  				e.getMessage());
                }
                catch (Error e)
                {
                 outputText.setText("error in expression.\n"+
    		  						   e.getMessage());
                }
                finally
                {
                  
                }
        	}
        });

        guiFrame.add(mainPanel, BorderLayout.NORTH);
        guiFrame.add(outputText, BorderLayout.CENTER);
        // Layout all component panels
        guiFrame.pack();
        
        //make sure the JFrame is visible
        guiFrame.setVisible(true);
	//AST
	
  }
}

PARSER_END(Main)

SKIP :
{
 "\r"
| "\t"
| "\n"
}

TOKEN : /* OPERATORS */
{
  < PLUS : "+" >
| < MINUS : "-" >
| < TIMES : "*" >
| < DIVIDE : "/" >
| < RECURSION : "rec" >
| < POINT : "." >
| < SPACE : " " >
| < IF : "if" >
| < THEN : "then" >
| < ELSE : "else" >
| < EGAL : "=" >
| < LAMBDA : "!" >
}

TOKEN :
{
  < NUMBER : (<DIGIT>)+  >
| 
  < VARIABLE : <LETTER> (< LETTER >|< DIGIT >)*  >
|
  < LEFT_PAREN : "(" >
|
  < RIGHT_PAREN : ")" >

}


TOKEN :
{
  <#DIGIT: ["0"-"9"]>
| <#LETTER: ["a"-"z", "A"-"Z"]>
}

int start()        :
{/*@bgen(jjtree) START */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) START */
   try {
/*@egen*/
   term() 
    (
      binary_operator() term()
    )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/   // "well formed formula"  
  {
    return 0;  // returns 0 on successful parse
  }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void term()      :
{/*@bgen(jjtree) VAR */
  SimpleNode jjtn000 = new SimpleNode(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VAR */
  try {
/*@egen*/
  symbol()  
|
  < LEFT_PAREN >  term()(binary_operator() term())* < RIGHT_PAREN >
|
  < MINUS >|< LAMBDA > term()  // Unary minus
|
  binary_operator() (term())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

void binary_operator()            :
{/*@bgen(jjtree) OPERATEUR */
  SimpleNode jjtn000 = new SimpleNode(JJTOPERATEUR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OPERATEUR */
  try {
/*@egen*/
  < PLUS >
| < MINUS >  // binary minus
| < TIMES >
| < DIVIDE >
| < RECURSION >
| < POINT >
| < IF >
| < THEN >
| < ELSE >
| < EGAL >
| < SPACE >
| < LAMBDA >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
  

void symbol()     :
{/*@bgen(jjtree) ID */
 SimpleNode jjtn000 = new SimpleNode(JJTID);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;
}
{/*@bgen(jjtree) ID */
  try {
/*@egen*/
  t= < NUMBER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    // Not necessary for parser construction - debugging code
    System.out.println("matched number: "+t);
  }
| 
  t= < VARIABLE >/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/  {System.out.println("matched variable: "+t);}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}